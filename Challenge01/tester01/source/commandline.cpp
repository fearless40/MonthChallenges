

#include "commandline.hpp"
#include "clipp.h"
#include <iostream>

namespace CommandLine
{

Options GlobalOptions;

const Options &get_program_options()
{
    return GlobalOptions;
}

std::optional<std::filesystem::path> ensure_file_exists(std::string_view filename)
{
    if (std::filesystem::exists(filename))
    {
        return filename;
    };
    return {};
}

bool does_file_exists(std::string_view filename)
{
    if (ensure_file_exists(filename))
        return true;
    return false;
}

std::optional<Options> parse(int argc, char *argv[])
{
    using namespace clipp;

    Options opt;
    std::string testFile;
    std::string testProgram;

    auto commandRun = (clipp::command("run").set(opt.mode, RunMode::Run),
                       value("test file", testFile) % "A test file generated by the generate command.",
                       (option("--timeout") % "Specify timeout value in milliseconds." &
                        value("milli seconds", opt.runTimeOutMilliseconds)),
                       required("-p", "--program") &
                           value("program to test", testProgram) %
                               "Specifify the program to test. It should follow the Challenge descriptions.");

    auto commandGenerate =
        (clipp::command("generate").set(opt.mode, RunMode::Generate),
         value("test file", testFile) % "The test file that desribes the tests and location of the test files.",
         (option("--NoErrors").set(opt.tests, TestModes::NoErrors) %
              "Generate only test files that are valid. No errors in the test files." |
          option("--all").set(opt.tests, TestModes::All) % "Generate all test files this is the default."),
         option("--huge").set(opt.huge) % "Generate a huge test file.");

    auto cli = (commandRun | commandGenerate | command("help").set(opt.mode, RunMode::Help),
                option("-v", "--version").call([] { std::cout << "version 1.0\n\n"; }).doc("show version"));

    auto result = clipp::parse(argc, argv, cli);

    if (!result)
    {
        std::cout << "Usuage: \n" << clipp::usage_lines(cli, "apptest") << '/n';
        return {};
    }

    if (opt.mode == RunMode::Help)
    {
        std::cout << clipp::make_man_page(cli, "apptest") << '/n';
        return {};
    }

    // Validate the files before continuing.

    switch (opt.mode)
    {
    case RunMode::Run: {
        auto fileProgram = ensure_file_exists(testProgram);
        if (!fileProgram)
        {
            std::cout << "The program to test was not found: " << testProgram << '/n';
            return {};
        }

        opt.testProgram = fileProgram.value();

        auto fileTest = ensure_file_exists(testFile);
        if (!fileTest)
        {
            std::cout << "The test file is not found: " << testFile << '/n';
            return {};
        }

        opt.testFile = fileTest.value();
    }
    break;

    case RunMode::Generate:

        if (does_file_exists(testFile))
        {
            std::cout << "\nFound an existing test file at: " << testFile << '\n';
            std::cout << "Generate a new file (y/n):";
            std::string overwrite{};
            std::cin >> overwrite;
            if (overwrite.find('n') != std::string::npos)
            {
                std::cout << "\nWill not generate new test file and test data. Quitting.\n";
                return {};
            }

            opt.overwrite = true;
        }
        opt.testFile = testFile;
        break;

    case RunMode::Help:
        return {};

    case RunMode::Quit:
        return {};

    case RunMode::Interactive:
    default:
        break;
    }

    GlobalOptions = opt;
    return opt;
}
} // namespace CommandLine